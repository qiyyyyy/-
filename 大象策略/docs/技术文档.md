# 大象策略技术文档

本文档详细说明大象策略的技术实现原理、数据结构和核心算法。适合开发者和技术人员阅读。

## T+1规则处理机制

大象策略专为A股T+1交易规则设计，能够精确区分当天买入的股票（不可卖出）和之前持有的股票（可卖出），具体实现如下：

### 1. 持仓记录设计

资金管理模块维护详细的持仓记录，关键字段包括：

```python
# 持仓记录结构示例
self.持仓 = {
    "股票代码1": {
        "总数量": 1000,         # 该股票的总持仓数量
        "可交易数量": 800,      # 当天可卖出的数量
        "冻结数量": 200,        # 当天买入的数量（T+1规则下被冻结）
        "买入时间": {           # 记录每笔买入的时间，用于自动解冻
            "批次1": {"数量": 200, "时间": 买入时间1},
            "批次2": {"数量": 800, "时间": 买入时间2}
        },
        "成本": 10.5,           # 平均成本价
        # 其他信息...
    },
    # 其他股票...
}
```

### 2. 买入股票处理

当执行买入操作时，系统会：

1. 更新该股票的总持仓数量
2. 将新买入的股票标记为"冻结数量"
3. 记录买入时间，用于后续确定解冻时机

```python
# 买入股票后的处理逻辑
def 更新买入记录(self, 股票代码, 买入数量, 买入价格):
    if 股票代码 not in self.持仓:
        self.持仓[股票代码] = {
            "总数量": 0, 
            "可交易数量": 0, 
            "冻结数量": 0, 
            "买入时间": {},
            "成本": 0
        }
    
    # 更新持仓数量
    self.持仓[股票代码]["总数量"] += 买入数量
    self.持仓[股票代码]["冻结数量"] += 买入数量
    
    # 记录买入时间
    批次ID = f"批次{len(self.持仓[股票代码]['买入时间']) + 1}"
    self.持仓[股票代码]["买入时间"][批次ID] = {
        "数量": 买入数量,
        "时间": datetime.now()
    }
    
    # 更新成本价
    # ... 成本计算逻辑 ...
```

### 3. 卖出前检查

每次准备卖出股票时，系统会检查可交易数量，确保只操作非冻结部分：

```python
# 卖出前检查可用数量
def 检查可卖数量(self, 股票代码, 请求数量):
    持仓信息 = self.持仓.get(股票代码, None)
    if not 持仓信息:
        return 0
    
    # 返回可交易数量和请求数量中的较小值
    return min(持仓信息["可交易数量"], 请求数量)
```

### 4. 交易日切换处理

系统在每个交易日开始时，会自动将前一交易日买入的股票解冻：

```python
# 交易日开始时更新持仓状态
def 日初更新持仓状态(self):
    今天 = datetime.now().date()
    for 股票代码, 持仓信息 in self.持仓.items():
        解冻数量 = 0
        待删除批次 = []
        
        # 检查每笔买入记录
        for 批次ID, 买入记录 in 持仓信息["买入时间"].items():
            买入日期 = 买入记录["时间"].date()
            if 买入日期 < 今天:  # 前一交易日买入的，可以解冻
                解冻数量 += 买入记录["数量"]
                待删除批次.append(批次ID)
        
        # 更新可交易和冻结数量
        持仓信息["可交易数量"] += 解冻数量
        持仓信息["冻结数量"] -= 解冻数量
        
        # 删除已解冻的买入记录
        for 批次ID in 待删除批次:
            del 持仓信息["买入时间"][批次ID]
```

### 5. 持久化存储

持仓状态会保存到本地文件，确保策略重启后仍能正确识别T+1状态：

```python
# 保存持仓状态
def 保存持仓数据(self):
    with open(self.持仓数据文件, 'w', encoding='utf-8') as f:
        json.dump(self.持仓, f, ensure_ascii=False, default=self._json序列化处理)

# 加载持仓状态
def 加载持仓数据(self):
    if os.path.exists(self.持仓数据文件):
        with open(self.持仓数据文件, 'r', encoding='utf-8') as f:
            持仓数据 = json.load(f)
            # 处理时间反序列化等...
            self.持仓 = 持仓数据
```

通过这种精确的持仓管理机制，大象策略能够严格遵守T+1交易规则，同时最大化利用可交易资金进行高频操作。策略的"先卖后买"模式也正是建立在对T+1规则的深度适应之上，确保了交易的合规性和高效性。

## 核心模块技术实现

### 大象识别模块

大象识别是策略的核心，用于发现大额委托买单支撑：

#### 1. 基本原理

大象识别模块通过分析盘口数据，寻找符合以下条件的买单：
- 委托金额大于设定的阈值（如100万元）
- 价格与卖一价格的差距小于设定的阈值（如0.3%）
- 在多个数据快照中连续存在
- 存在时间超过稳定时间阈值

#### 2. 核心代码实现

```python
class 大象识别器:
    def __init__(self, 大象委托量阈值=1000000, 大象价差阈值=0.3, 大象确认次数=3, 大象稳定时间=5):
        self.大象委托量阈值 = 大象委托量阈值  # 单位：元
        self.大象价差阈值 = 大象价差阈值 / 100  # 转换为小数
        self.大象确认次数 = 大象确认次数
        self.大象稳定时间 = 大象稳定时间  # 单位：秒
        
        # 大象跟踪状态
        self.大象跟踪 = {}  # 格式: {股票代码: {价格: {确认次数, 首次发现时间}}}
        
    def 检测大象(self, 股票代码, 盘口数据):
        """
        分析盘口数据，检测是否存在大象买单
        返回: (是否存在大象, 大象价格)
        """
        if not 盘口数据 or "bid" not in 盘口数据:
            return False, None
            
        买盘 = 盘口数据["bid"]  # 买盘数据，格式: [[价格, 数量], ...]
        卖盘 = 盘口数据["ask"]  # 卖盘数据
        
        if not 买盘 or not 卖盘:
            return False, None
            
        卖一价 = 卖盘[0][0]
        当前时间 = datetime.now()
        
        # 分析买盘所有档位
        大象价格 = None
        for 价格, 数量 in 买盘:
            # 计算委托金额和价差
            委托金额 = 价格 * 数量
            价差比例 = (卖一价 - 价格) / 价格
            
            # 判断是否符合大象条件
            if 委托金额 >= self.大象委托量阈值 and 价差比例 <= self.大象价差阈值:
                # 更新大象跟踪状态
                if 股票代码 not in self.大象跟踪:
                    self.大象跟踪[股票代码] = {}
                    
                if 价格 not in self.大象跟踪[股票代码]:
                    self.大象跟踪[股票代码][价格] = {
                        "确认次数": 1,
                        "首次发现时间": 当前时间
                    }
                else:
                    self.大象跟踪[股票代码][价格]["确认次数"] += 1
                
                # 检查是否满足确认条件
                track = self.大象跟踪[股票代码][价格]
                经过时间 = (当前时间 - track["首次发现时间"]).total_seconds()
                
                if track["确认次数"] >= self.大象确认次数 and 经过时间 >= self.大象稳定时间:
                    大象价格 = 价格
                    break
            
        # 清理过期的大象跟踪记录
        self._清理过期记录(股票代码, 买盘)
        
        return 大象价格 is not None, 大象价格
        
    def _清理过期记录(self, 股票代码, 买盘):
        """清理不再存在于买盘中的价格记录"""
        if 股票代码 not in self.大象跟踪:
            return
            
        当前买盘价格 = [价格 for 价格, _ in 买盘]
        待删除价格 = []
        
        for 价格 in self.大象跟踪[股票代码]:
            if 价格 not in 当前买盘价格:
                待删除价格.append(价格)
                
        for 价格 in 待删除价格:
            del self.大象跟踪[股票代码][价格]
            
        # 如果股票没有跟踪记录了，删除整个股票的跟踪
        if not self.大象跟踪[股票代码]:
            del self.大象跟踪[股票代码]
```

#### 3. 算法优化

为提高识别效率和准确性，算法做了以下优化：
- 使用缓存机制减少重复计算
- 采用动态价差阈值，根据市场波动自动调整
- 实现了大象消失的快速检测，避免错误交易
- 使用委托金额而非委托量作为判断标准，适应不同价位股票

### 资金管理模块

资金管理模块负责管理股票和现金资产，维持资金平衡：

#### 1. 资金分配原则

- 将总资产分为股票池和现金池，目标比例通常为50/50
- 股票池负责提供可交易股票，现金池负责买回股票和提供安全保障
- 单只股票的最大持仓比例受到限制，避免集中风险

#### 2. 核心数据结构

```python
class 资金管理器:
    def __init__(self, 股票池比例=0.5, 买回保障金比例=0.3, 单股最大仓位比例=0.1):
        self.股票池比例 = 股票池比例
        self.买回保障金比例 = 买回保障金比例
        self.单股最大仓位比例 = 单股最大仓位比例
        
        # 资产状态
        self.总资产 = 0.0
        self.现金 = 0.0
        self.持仓 = {}  # 详细持仓结构见T+1规则处理机制部分
        
        # 资金分配状态
        self.股票池资金 = 0.0
        self.现金池资金 = 0.0
        self.买回保障金 = 0.0
        self.可用资金 = 0.0
```

#### 3. 资金再平衡算法

```python
def 资金再平衡(self):
    """
    在交易后检查并调整资金平衡状态
    """
    # 计算当前总资产
    持仓市值 = sum(self._计算股票市值(股票代码) for 股票代码 in self.持仓)
    self.总资产 = self.现金 + 持仓市值
    
    # 计算理想的资金分配
    目标股票池资金 = self.总资产 * self.股票池比例
    目标现金池资金 = self.总资产 * (1 - self.股票池比例)
    目标买回保障金 = 目标现金池资金 * self.买回保障金比例
    
    # 当前的资金分配
    当前股票池资金 = 持仓市值
    当前现金池资金 = self.现金
    
    # 判断是否需要再平衡
    不平衡度 = abs(当前股票池资金 - 目标股票池资金) / self.总资产
    
    # 如果不平衡度超过阈值，需要调整
    if 不平衡度 > 0.05:  # 5%的不平衡容忍度
        if 当前股票池资金 > 目标股票池资金:
            # 股票过多，需要卖出
            return {
                "需要平衡": True,
                "方向": "减少股票",
                "金额": 当前股票池资金 - 目标股票池资金
            }
        else:
            # 股票过少，需要买入
            return {
                "需要平衡": True,
                "方向": "增加股票",
                "金额": 目标股票池资金 - 当前股票池资金
            }
    
    # 更新资金池状态
    self.股票池资金 = 当前股票池资金
    self.现金池资金 = 当前现金池资金
    self.买回保障金 = 目标买回保障金
    self.可用资金 = 当前现金池资金 - 目标买回保障金
    
    return {"需要平衡": False}
```

#### 4. 交易资金检查

在执行交易前，系统会检查资金是否足够：

```python
def 检查买入资金(self, 股票代码, 买入金额):
    """
    检查是否有足够资金买入股票
    返回可用的买入金额
    """
    # 检查可用资金
    if self.可用资金 <= 0:
        return 0
        
    # 检查单股持仓限制
    当前持仓金额 = self._计算股票市值(股票代码)
    最大允许持仓 = self.总资产 * self.单股最大仓位比例
    
    if 当前持仓金额 >= 最大允许持仓:
        return 0
        
    # 计算可买入金额
    可增加持仓 = 最大允许持仓 - 当前持仓金额
    实际可用 = min(self.可用资金, 可增加持仓, 买入金额)
    
    return 实际可用
```

### 交易执行模块

交易执行模块负责处理订单创建、提交和跟踪：

#### 1. 模块结构

交易执行模块负责将大象识别的结果转化为实际交易操作，确保交易的及时性和有效性：

```python
class 交易执行器:
    def __init__(self, 价格偏移量=0.01, 卖出偏移量倍数=2, 买入偏移量倍数=1, 等待时间=30, 冷却时间=60):
        self.价格偏移量 = 价格偏移量  # 最小价格变动单位
        self.卖出偏移量倍数 = 卖出偏移量倍数  # 卖出价高于大象价格的偏移量倍数
        self.买入偏移量倍数 = 买入偏移量倍数  # 买入价高于大象价格的偏移量倍数
        self.等待时间 = 等待时间  # 等待订单成交的最长时间(秒)
        self.冷却时间 = 冷却时间  # 同一股票交易后的冷却时间(秒)
        
        # 交易状态记录
        self.活跃订单 = {}  # 当前活跃的订单
        self.冷却股票 = {}  # 处于冷却期的股票及其解冻时间
        self.交易历史 = []  # 交易历史记录
```

#### 2. 交易流程

交易执行采用有限状态机设计，确保每个交易周期稳定可控：

```python
def 执行交易(self, 股票代码, 大象价格, 持仓数据):
    """
    基于大象价格执行先卖后买交易
    
    参数:
        股票代码: 股票代码
        大象价格: 识别到的大象买单价格
        持仓数据: 当前持仓数据
        
    返回:
        交易结果字典
    """
    # 检查股票是否在冷却期
    if self._检查冷却状态(股票代码):
        return {"状态": "冷却中", "股票代码": 股票代码}
    
    # 检查是否有可交易的股票数量
    可卖数量 = 持仓数据.检查可卖数量(股票代码)
    if 可卖数量 <= 0:
        return {"状态": "无可卖股票", "股票代码": 股票代码}
    
    # 计算交易价格
    卖出价格 = self._计算卖出价格(大象价格)
    预计买回价格 = self._计算买回价格(大象价格)
    
    # 创建卖出订单
    卖出订单 = self._创建卖出订单(股票代码, 卖出价格, 可卖数量)
    self.活跃订单[卖出订单["订单ID"]] = {
        "类型": "卖出",
        "股票代码": 股票代码,
        "价格": 卖出价格,
        "数量": 可卖数量,
        "创建时间": datetime.now(),
        "状态": "待成交",
        "预计买回价格": 预计买回价格
    }
    
    # 返回交易创建结果
    return {
        "状态": "已创建卖出订单",
        "股票代码": 股票代码,
        "订单ID": 卖出订单["订单ID"],
        "卖出价格": 卖出价格,
        "预计买回价格": 预计买回价格
    }
```

#### 3. 订单管理算法

交易执行模块实现了订单的全生命周期管理，从创建到成交再到后续买回：

```python
def 更新订单状态(self, 成交数据):
    """
    更新订单状态并处理成交回报
    
    参数:
        成交数据: 交易所返回的成交回报数据
    """
    订单ID = 成交数据["订单ID"]
    if 订单ID not in self.活跃订单:
        return
    
    订单 = self.活跃订单[订单ID]
    成交价格 = 成交数据["成交价格"]
    成交数量 = 成交数据["成交数量"]
    
    # 更新订单状态
    if 成交数量 >= 订单["数量"]:
        订单["状态"] = "已完成"
    else:
        订单["状态"] = "部分成交"
        订单["数量"] -= 成交数量
    
    # 如果是卖出订单成交，创建对应的买回订单
    if 订单["类型"] == "卖出" and (订单["状态"] == "已完成" or 订单["状态"] == "部分成交"):
        买回价格 = 订单["预计买回价格"]
        买回订单 = self._创建买入订单(订单["股票代码"], 买回价格, 成交数量)
        
        self.活跃订单[买回订单["订单ID"]] = {
            "类型": "买入",
            "股票代码": 订单["股票代码"],
            "价格": 买回价格,
            "数量": 成交数量,
            "创建时间": datetime.now(),
            "状态": "待成交",
            "关联卖出订单": 订单ID
        }
        
        # 记录交易对
        self.交易历史.append({
            "股票代码": 订单["股票代码"],
            "卖出价格": 成交价格,
            "卖出数量": 成交数量,
            "卖出时间": datetime.now(),
            "预计买回价格": 买回价格,
            "卖出订单ID": 订单ID,
            "买回订单ID": 买回订单["订单ID"],
            "状态": "已卖出待买回"
        })
    
    # 如果是买入订单成交，更新交易历史并设置冷却期
    if 订单["类型"] == "买入" and (订单["状态"] == "已完成" or 订单["状态"] == "部分成交"):
        # 更新关联的交易历史
        for 记录 in self.交易历史:
            if 记录["买回订单ID"] == 订单ID:
                记录["买回价格"] = 成交价格
                记录["买回数量"] = 成交数量
                记录["买回时间"] = datetime.now()
                记录["状态"] = "已完成"
                记录["盈亏"] = (记录["卖出价格"] - 成交价格) * 成交数量
        
        # 设置股票冷却期
        self.冷却股票[订单["股票代码"]] = datetime.now() + timedelta(seconds=self.冷却时间)
    
    # 如果订单完成，从活跃订单中移除
    if 订单["状态"] == "已完成":
        del self.活跃订单[订单ID]
```

#### 4. 超时订单处理

为避免订单长时间未成交导致资金占用，系统实现了订单超时检查和取消机制：

```python
def 检查超时订单(self):
    """
    检查并处理超时未成交的订单
    """
    当前时间 = datetime.now()
    待取消订单IDs = []
    
    for 订单ID, 订单 in self.活跃订单.items():
        # 计算订单存在时间
        订单时长 = (当前时间 - 订单["创建时间"]).total_seconds()
        
        # 如果超过等待时间，标记为待取消
        if 订单时长 > self.等待时间:
            待取消订单IDs.append(订单ID)
    
    # 取消超时订单
    for 订单ID in 待取消订单IDs:
        self._取消订单(订单ID)
        # 如果是卖出订单被取消，直接从活跃订单移除
        if self.活跃订单[订单ID]["类型"] == "卖出":
            del self.活跃订单[订单ID]
        # 如果是买入订单被取消，需要特殊处理
        else:
            买入订单 = self.活跃订单[订单ID]
            # 更新交易历史
            for 记录 in self.交易历史:
                if 记录["买回订单ID"] == 订单ID:
                    记录["状态"] = "买回失败"
            
            # 设置股票冷却期，避免频繁交易
            self.冷却股票[买入订单["股票代码"]] = 当前时间 + timedelta(seconds=self.冷却时间 * 2)
            
            # 从活跃订单移除
            del self.活跃订单[订单ID]
```

#### 5. 价格计算算法

交易价格的精确计算是保证交易有效性的关键：

```python
def _计算卖出价格(self, 大象价格):
    """
    基于大象价格计算卖出价格
    卖出价略高于大象价格，以确保能够成交
    """
    return 大象价格 + self.价格偏移量 * self.卖出偏移量倍数

def _计算买回价格(self, 大象价格):
    """
    基于大象价格计算买回价格
    买回价略高于大象价格但低于卖出价，以确保能获利
    """
    return 大象价格 + self.价格偏移量 * self.买入偏移量倍数
```

### 风险控制模块

风险控制是大象策略安全稳定运行的保障，实现了多层次的风险防范机制：

#### 1. 风控模块结构

风险控制模块负责监控交易过程中的各类风险指标，并在超出阈值时触发相应的风控措施：

```python
class 风险控制器:
    def __init__(self, 单笔最大亏损比例=0.001, 单股最大亏损比例=0.005, 日内最大亏损比例=0.01, 
                单股最大交易次数=5, 总交易次数限制=20):
        # 风控阈值参数
        self.单笔最大亏损比例 = 单笔最大亏损比例  # 单笔交易最大亏损占总资产比例
        self.单股最大亏损比例 = 单股最大亏损比例  # 单只股票日内最大亏损占总资产比例
        self.日内最大亏损比例 = 日内最大亏损比例  # 日内最大总亏损占总资产比例
        self.单股最大交易次数 = 单股最大交易次数  # 单只股票日内最大交易次数
        self.总交易次数限制 = 总交易次数限制      # 日内总交易次数限制
        
        # 风控状态记录
        self.交易计数 = {}  # 格式: {股票代码: 交易次数}
        self.总交易次数 = 0
        self.单股亏损记录 = {}  # 格式: {股票代码: 累计亏损金额}
        self.日内总亏损 = 0.0
        self.风控触发记录 = []  # 记录风控触发的历史
        self.风控状态 = True  # True表示正常交易，False表示已触发风控停止交易
```

#### 2. 交易前风险检查

在每笔交易前，系统会进行全面的风险评估，确保交易符合风控要求：

```python
def 交易前检查(self, 股票代码, 交易金额, 总资产):
    """
    交易执行前的风险检查
    
    参数:
        股票代码: 交易的股票代码
        交易金额: 拟交易的金额
        总资产: 当前总资产
        
    返回:
        字典，包含检查结果和原因
    """
    # 检查是否已触发风控停止
    if not self.风控状态:
        return {
            "允许交易": False,
            "原因": "全局风控已触发，暂停所有交易"
        }
    
    # 检查单笔交易金额限制
    单笔最大交易金额 = 总资产 * self.单笔最大亏损比例 * 10  # 假设最大亏损为10%
    if 交易金额 > 单笔最大交易金额:
        return {
            "允许交易": False,
            "原因": f"交易金额 {交易金额} 超过单笔限制 {单笔最大交易金额}"
        }
    
    # 检查交易次数限制
    if 股票代码 in self.交易计数 and self.交易计数[股票代码] >= self.单股最大交易次数:
        return {
            "允许交易": False,
            "原因": f"股票 {股票代码} 已达到最大交易次数限制 {self.单股最大交易次数}"
        }
    
    if self.总交易次数 >= self.总交易次数限制:
        return {
            "允许交易": False,
            "原因": f"当日总交易次数已达到限制 {self.总交易次数限制}"
        }
    
    # 检查亏损限制
    单股最大亏损金额 = 总资产 * self.单股最大亏损比例
    if 股票代码 in self.单股亏损记录 and self.单股亏损记录[股票代码] >= 单股最大亏损金额:
        return {
            "允许交易": False,
            "原因": f"股票 {股票代码} 已达到最大亏损限制 {单股最大亏损金额}"
        }
    
    日内最大亏损金额 = 总资产 * self.日内最大亏损比例
    if self.日内总亏损 >= 日内最大亏损金额:
        return {
            "允许交易": False,
            "原因": f"日内总亏损已达到最大限制 {日内最大亏损金额}"
        }
    
    # 通过所有风控检查
    return {
        "允许交易": True
    }
```

#### 3. 交易后风险更新

每笔交易完成后，系统会更新风险状态，为后续交易决策提供依据：

```python
def 更新交易记录(self, 股票代码, 盈亏金额, 总资产):
    """
    交易完成后更新风控状态
    
    参数:
        股票代码: 交易的股票代码
        盈亏金额: 本次交易的盈亏金额
        总资产: 当前总资产
    """
    # 更新交易次数
    if 股票代码 not in self.交易计数:
        self.交易计数[股票代码] = 0
    self.交易计数[股票代码] += 1
    self.总交易次数 += 1
    
    # 如果是亏损交易，更新亏损记录
    if 盈亏金额 < 0:
        # 更新单股亏损
        if 股票代码 not in self.单股亏损记录:
            self.单股亏损记录[股票代码] = 0
        self.单股亏损记录[股票代码] += abs(盈亏金额)
        
        # 更新日内总亏损
        self.日内总亏损 += abs(盈亏金额)
        
        # 检查是否触发风控
        self._检查风控触发(股票代码, 总资产)
```

#### 4. 风控触发机制

当风险指标超过阈值时，系统会自动触发风控措施：

```python
def _检查风控触发(self, 股票代码, 总资产):
    """
    检查是否需要触发风控措施
    
    参数:
        股票代码: 交易的股票代码
        总资产: 当前总资产
    """
    触发原因 = None
    
    # 检查单股亏损是否触发风控
    单股最大亏损金额 = 总资产 * self.单股最大亏损比例
    if 股票代码 in self.单股亏损记录 and self.单股亏损记录[股票代码] >= 单股最大亏损金额:
        触发原因 = f"股票 {股票代码} 亏损 {self.单股亏损记录[股票代码]} 超过阈值 {单股最大亏损金额}"
    
    # 检查日内总亏损是否触发风控
    日内最大亏损金额 = 总资产 * self.日内最大亏损比例
    if self.日内总亏损 >= 日内最大亏损金额:
        触发原因 = f"日内总亏损 {self.日内总亏损} 超过阈值 {日内最大亏损金额}"
    
    # 如果触发风控，记录并更新状态
    if 触发原因:
        self.风控状态 = False
        self.风控触发记录.append({
            "时间": datetime.now(),
            "原因": 触发原因,
            "累计亏损": self.日内总亏损,
            "总资产": 总资产
        })
        
        # 记录风控日志
        self._记录风控日志(触发原因)
```

#### 5. 风控日志与监控

系统实现了完善的风控日志记录和监控机制，便于事后分析和改进：

```python
def _记录风控日志(self, 原因):
    """记录风控触发日志"""
    日志内容 = f"[风控触发] {datetime.now()} - {原因}"
    # 写入日志文件
    with open("logs/风控日志.txt", "a", encoding="utf-8") as f:
        f.write(日志内容 + "\n")
    
    # 同时输出到控制台
    print(日志内容)
```

#### 6. 风控复位机制

在特定条件下，系统允许手动复位风控状态，恢复交易能力：

```python
def 复位风控(self, 授权码="admin"):
    """
    手动复位风控状态
    
    参数:
        授权码: 管理员授权码，用于验证操作权限
        
    返回:
        是否成功复位
    """
    if 授权码 != "admin":  # 实际应用中应使用更安全的验证方式
        return False
    
    # 复位风控状态
    self.风控状态 = True
    
    # 记录复位操作
    self.风控触发记录.append({
        "时间": datetime.now(),
        "原因": "管理员手动复位风控状态",
        "操作": "复位"
    })
    
    # 记录复位日志
    self._记录风控日志("管理员手动复位风控状态")
    
    return True
```

### 网页管理模块

网页管理模块提供了远程监控和控制策略的能力，增强了策略的可用性和管理效率：

#### 1. 服务器架构

网页管理基于轻量级Web服务器实现，允许通过浏览器远程访问策略状态和控制功能：

```python
class 网页管理器:
    def __init__(self, 端口=8088, 自动打开浏览器=True):
        self.端口 = 端口
        self.自动打开浏览器 = 自动打开浏览器
        self.服务器 = None
        self.策略实例 = None  # 指向主策略实例的引用
        self.已启动 = False
        
        # API路由配置
        self.路由表 = {
            '/': self._首页处理,
            '/api/status': self._状态API,
            '/api/params': self._参数API,
            '/api/trades': self._交易记录API,
            '/api/control': self._控制API,
            '/api/logs': self._日志API
        }
    
    def 启动服务器(self, 策略实例):
        """启动Web服务器"""
        if self.已启动:
            return
        
        self.策略实例 = 策略实例
        
        # 启动HTTP服务器
        def _运行服务器():
            from http.server import HTTPServer, BaseHTTPRequestHandler
            import json, urllib.parse
            
            class 请求处理器(BaseHTTPRequestHandler):
                def do_GET(self):
                    self.server.网页管理实例._处理请求(self)
                
                def do_POST(self):
                    self.server.网页管理实例._处理请求(self)
            
            服务器 = HTTPServer(('localhost', self.端口), 请求处理器)
            服务器.网页管理实例 = self
            print(f"网页管理服务器已启动，访问 http://localhost:{self.端口}")
            
            if self.自动打开浏览器:
                self._打开浏览器()
                
            self.已启动 = True
            服务器.serve_forever()
        
        # 在新线程中启动服务器
        import threading
        self.服务器线程 = threading.Thread(target=_运行服务器)
        self.服务器线程.daemon = True
        self.服务器线程.start()
```

#### 2. API接口设计

网页管理模块实现了REST风格的API接口，提供数据查询和控制功能：

```python
def _处理请求(self, 处理器):
    """处理HTTP请求并路由到对应处理函数"""
    try:
        # 解析请求路径
        路径 = 处理器.path.split('?')[0]
        
        # 查找路由处理函数
        if 路径 in self.路由表:
            self.路由表[路径](处理器)
        else:
            self._提供静态文件(处理器)
    
    except Exception as e:
        # 处理异常
        self._返回错误(处理器, 500, str(e))

def _状态API(self, 处理器):
    """返回策略当前状态的API"""
    状态数据 = {
        "运行状态": self.策略实例.运行状态,
        "总资产": self.策略实例.资金管理.总资产,
        "现金": self.策略实例.资金管理.现金,
        "股票持仓": self.策略实例.资金管理.持仓,
        "今日交易": len(self.策略实例.交易执行.交易历史),
        "风控状态": self.策略实例.风险控制.风控状态,
        "大象跟踪": self.策略实例.大象识别.大象跟踪,
        "更新时间": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    
    self._返回JSON(处理器, 状态数据)

def _参数API(self, 处理器):
    """参数查询和设置API"""
    if 处理器.command == 'GET':
        # 返回当前参数
        参数 = self._获取所有参数()
        self._返回JSON(处理器, 参数)
    
    elif 处理器.command == 'POST':
        # 更新参数
        内容长度 = int(处理器.headers['Content-Length'])
        请求体 = 处理器.rfile.read(内容长度).decode('utf-8')
        新参数 = json.loads(请求体)
        
        # 更新参数
        更新结果 = self._更新参数(新参数)
        self._返回JSON(处理器, 更新结果)
```

#### 3. 前端界面

网页管理模块内置了响应式前端界面，提供直观的数据可视化和操作体验：

```python
def _首页处理(self, 处理器):
    """返回Web界面HTML"""
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>大象策略 - 管理界面</title>
        <style>
            /* CSS样式略 */
        </style>
    </head>
    <body>
        <div class="container">
            <header>
                <h1>大象策略管理界面</h1>
                <div class="status-indicator" id="status-indicator"></div>
            </header>
            
            <div class="tabs">
                <div class="tab-header">
                    <button class="tab-btn active" data-tab="dashboard">首页</button>
                    <button class="tab-btn" data-tab="stats">策略统计</button>
                    <button class="tab-btn" data-tab="trades">交易记录</button>
                    <button class="tab-btn" data-tab="params">参数设置</button>
                    <button class="tab-btn" data-tab="logs">运行日志</button>
                </div>
                
                <div class="tab-content">
                    <!-- 各个标签页的内容 -->
                    <div class="tab-pane active" id="dashboard">
                        <div class="card">
                            <h2>策略概览</h2>
                            <div id="overview-data"></div>
                        </div>
                        <div class="card">
                            <h2>最近交易</h2>
                            <div id="recent-trades"></div>
                        </div>
                    </div>
                    
                    <!-- 其他标签页内容略 -->
                </div>
            </div>
        </div>
        
        <script>
            // JavaScript代码略
        </script>
    </body>
    </html>
    """
    
    self._返回HTML(处理器, html)
```

#### 4. 实时数据更新

网页管理模块实现了基于轮询的实时数据更新机制，确保界面数据的及时性：

```python
def _交易记录API(self, 处理器):
    """返回交易记录数据"""
    # 获取查询参数
    查询参数 = self._解析查询参数(处理器.path)
    日期 = 查询参数.get('date', None)
    股票代码 = 查询参数.get('code', None)
    
    # 过滤交易记录
    交易记录 = self.策略实例.交易执行.交易历史
    
    if 日期:
        # 按日期过滤
        日期 = datetime.strptime(日期, "%Y-%m-%d").date()
        交易记录 = [记录 for 记录 in 交易记录 if 记录["卖出时间"].date() == 日期]
    
    if 股票代码:
        # 按股票代码过滤
        交易记录 = [记录 for 记录 in 交易记录 if 记录["股票代码"] == 股票代码]
    
    # 计算统计信息
    盈利交易 = [记录 for 记录 in 交易记录 if 记录.get("盈亏", 0) > 0]
    亏损交易 = [记录 for 记录 in 交易记录 if 记录.get("盈亏", 0) < 0]
    
    统计 = {
        "总交易数": len(交易记录),
        "盈利交易数": len(盈利交易),
        "亏损交易数": len(亏损交易),
        "总盈亏": sum(记录.get("盈亏", 0) for 记录 in 交易记录 if "盈亏" in 记录),
        "胜率": len(盈利交易) / len(交易记录) if 交易记录 else 0
    }
    
    # 返回数据
    self._返回JSON(处理器, {
        "records": 交易记录,
        "stats": 统计
    })
```

#### 5. 安全机制

网页管理模块内置了基本的安全验证机制，防止未授权访问：

```python
def _控制API(self, 处理器):
    """策略控制API"""
    if 处理器.command != 'POST':
        self._返回错误(处理器, 405, "仅支持POST请求")
        return
    
    # 读取请求体
    内容长度 = int(处理器.headers['Content-Length'])
    请求体 = 处理器.rfile.read(内容长度).decode('utf-8')
    控制命令 = json.loads(请求体)
    
    # 验证访问权限
    if not self._验证访问权限(控制命令.get("token", "")):
        self._返回错误(处理器, 403, "访问未授权")
        return
    
    # 执行控制命令
    命令类型 = 控制命令.get("command", "")
    结果 = {"success": False, "message": "未知命令"}
    
    if 命令类型 == "start":
        # 启动策略
        self.策略实例.启动()
        结果 = {"success": True, "message": "策略已启动"}
    
    elif 命令类型 == "stop":
        # 停止策略
        self.策略实例.停止()
        结果 = {"success": True, "message": "策略已停止"}
    
    elif 命令类型 == "reset_risk":
        # 复位风控
        if self.策略实例.风险控制.复位风控(控制命令.get("auth_code", "")):
            结果 = {"success": True, "message": "风控状态已复位"}
        else:
            结果 = {"success": False, "message": "风控复位失败，授权码无效"}
    
    # 返回结果
    self._返回JSON(处理器, 结果)

def _验证访问权限(self, token):
    """验证访问令牌是否有效"""
    # 实际应用中应使用更安全的验证方式，如JWT
    return token == "your_secure_token" or token == self.策略实例.网页管理密码
```

### 测试模块

测试模块是大象策略的重要组成部分，确保策略各个组件正常工作并符合预期：

#### 1. 测试框架设计

测试模块基于Python标准库unittest框架实现，支持自动化测试和结果报告：

```python
import unittest
import sys
import os
import json
from datetime import datetime, timedelta

class 大象策略测试:
    """大象策略测试框架"""
    
    def __init__(self):
        self.测试用例 = []
        self.测试结果 = {}
    
    def 运行所有测试(self):
        """运行所有注册的测试"""
        # 添加所有测试类
        self._注册测试类(资金管理测试)
        self._注册测试类(大象识别测试)
        self._注册测试类(交易执行测试)
        self._注册测试类(风险控制测试)
        self._注册测试类(网页管理测试)
        
        # 创建测试套件
        测试套件 = unittest.TestSuite()
        for 测试类 in self.测试用例:
            测试类实例 = unittest.defaultTestLoader.loadTestsFromTestCase(测试类)
            测试套件.addTest(测试类实例)
        
        # 运行测试并收集结果
        测试结果收集器 = unittest.TestResult()
        测试套件.run(测试结果收集器)
        
        # 处理测试结果
        self.测试结果 = {
            "总测试数": 测试结果收集器.testsRun,
            "成功数": 测试结果收集器.testsRun - len(测试结果收集器.failures) - len(测试结果收集器.errors),
            "失败数": len(测试结果收集器.failures),
            "错误数": len(测试结果收集器.errors),
            "成功率": (测试结果收集器.testsRun - len(测试结果收集器.failures) - len(测试结果收集器.errors)) / 测试结果收集器.testsRun if 测试结果收集器.testsRun > 0 else 0,
            "失败详情": [f"{失败[0]}: {失败[1]}" for 失败 in 测试结果收集器.failures],
            "错误详情": [f"{错误[0]}: {错误[1]}" for 错误 in 测试结果收集器.errors]
        }
        
        # 输出测试结果
        self._输出测试报告()
        
        return self.测试结果
    
    def _注册测试类(self, 测试类):
        """注册测试类到测试套件"""
        self.测试用例.append(测试类)
    
    def _输出测试报告(self):
        """输出格式化的测试报告"""
        print("\n" + "="*50)
        print("大象策略测试报告")
        print("="*50)
        print(f"测试时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"总测试数: {self.测试结果['总测试数']}")
        print(f"成功: {self.测试结果['成功数']}")
        print(f"失败: {self.测试结果['失败数']}")
        print(f"错误: {self.测试结果['错误数']}")
        print(f"成功率: {self.测试结果['成功率']*100:.2f}%")
        
        if self.测试结果['失败数'] > 0:
            print("\n失败的测试:")
            for 失败 in self.测试结果['失败详情']:
                print(f"- {失败}")
        
        if self.测试结果['错误数'] > 0:
            print("\n错误的测试:")
            for 错误 in self.测试结果['错误详情']:
                print(f"- {错误}")
        
        print("="*50 + "\n")
```

#### 2. 资金管理测试

资金管理测试验证资金分配、持仓管理和T+1规则处理的正确性：

```python
class 资金管理测试(unittest.TestCase):
    """资金管理模块测试用例"""
    
    def setUp(self):
        """测试前准备"""
        from modules.资金管理 import 资金管理器
        self.资金管理 = 资金管理器(股票池比例=0.5, 买回保障金比例=0.3, 单股最大仓位比例=0.1)
        self.资金管理.现金 = 1000000.0  # 100万初始资金
        self.资金管理.持仓 = {}
    
    def test_资金分配(self):
        """测试资金池分配逻辑"""
        # 初始状态下，全部为现金
        结果 = self.资金管理.资金再平衡()
        self.assertTrue(结果["需要平衡"])
        self.assertEqual(结果["方向"], "增加股票")
        self.assertAlmostEqual(结果["金额"], 500000.0)  # 应该买入50万的股票
        
        # 模拟持有50万股票
        self.资金管理.持仓 = {"000001": {"总数量": 10000, "可交易数量": 10000, "冻结数量": 0, "成本": 50.0}}
        self.资金管理._计算股票市值 = lambda 代码: 500000.0 if 代码 == "000001" else 0
        
        # 此时应该平衡
        结果 = self.资金管理.资金再平衡()
        self.assertFalse(结果["需要平衡"])
        self.assertEqual(self.资金管理.可用资金, 350000.0)  # 现金池70万，保障金30万，可用资金35万
    
    def test_T1规则处理(self):
        """测试T+1规则处理"""
        # 模拟买入股票
        self.资金管理.更新买入记录("000001", 1000, 50.0)
        
        # 检查持仓状态
        self.assertEqual(self.资金管理.持仓["000001"]["总数量"], 1000)
        self.assertEqual(self.资金管理.持仓["000001"]["可交易数量"], 0)
        self.assertEqual(self.资金管理.持仓["000001"]["冻结数量"], 1000)
        
        # 检查可卖数量
        可卖 = self.资金管理.检查可卖数量("000001", 1000)
        self.assertEqual(可卖, 0)  # 当天买入的不可卖
        
        # 模拟日期变更
        买入时间 = list(self.资金管理.持仓["000001"]["买入时间"].values())[0]["时间"]
        # 修改买入时间为昨天
        list(self.资金管理.持仓["000001"]["买入时间"].values())[0]["时间"] = 买入时间 - timedelta(days=1)
        
        # 模拟日初更新
        self.资金管理.日初更新持仓状态()
        
        # 再次检查可卖数量
        可卖 = self.资金管理.检查可卖数量("000001", 1000)
        self.assertEqual(可卖, 1000)  # 昨天买入的今天可卖
```

#### 3. 大象识别测试

大象识别测试验证大额买单支撑的识别逻辑和稳定性：

```python
class 大象识别测试(unittest.TestCase):
    """大象识别模块测试用例"""
    
    def setUp(self):
        """测试前准备"""
        from modules.大象识别 import 大象识别器
        self.大象识别 = 大象识别器(大象委托量阈值=1000000, 大象价差阈值=0.3, 大象确认次数=3, 大象稳定时间=5)
    
    def test_大象识别逻辑(self):
        """测试大象识别的基本逻辑"""
        # 创建模拟盘口数据
        模拟盘口 = {
            "bid": [[9.90, 10000], [9.85, 50000], [9.80, 102041]],  # 第三档是100万元
            "ask": [[10.00, 5000], [10.05, 3000]]
        }
        
        # 第一次识别，应该开始跟踪但不确认
        有大象, 大象价格 = self.大象识别.检测大象("000001", 模拟盘口)
        self.assertFalse(有大象)
        self.assertIsNone(大象价格)
        
        # 确认大象跟踪状态已建立
        self.assertIn("000001", self.大象识别.大象跟踪)
        self.assertIn(9.80, self.大象识别.大象跟踪["000001"])
        self.assertEqual(self.大象识别.大象跟踪["000001"][9.80]["确认次数"], 1)
        
        # 模拟后续几次检测
        有大象, 大象价格 = self.大象识别.检测大象("000001", 模拟盘口)
        有大象, 大象价格 = self.大象识别.检测大象("000001", 模拟盘口)
        
        # 此时确认次数应该达到3，但时间可能不够
        self.assertEqual(self.大象识别.大象跟踪["000001"][9.80]["确认次数"], 3)
        self.assertFalse(有大象)  # 时间不够仍不确认
        
        # 修改首次发现时间使其满足稳定时间要求
        首次时间 = self.大象识别.大象跟踪["000001"][9.80]["首次发现时间"]
        self.大象识别.大象跟踪["000001"][9.80]["首次发现时间"] = 首次时间 - timedelta(seconds=6)
        
        # 再次检测，应该确认大象
        有大象, 大象价格 = self.大象识别.检测大象("000001", 模拟盘口)
        self.assertTrue(有大象)
        self.assertEqual(大象价格, 9.80)
```

#### 4. 系统集成测试

系统集成测试验证各个模块的协同工作能力和完整交易流程：

```python
class 系统集成测试(unittest.TestCase):
    """系统级集成测试用例"""
    
    def setUp(self):
        """测试前准备，创建完整的策略实例"""
        from 大象策略 import 大象策略
        self.策略 = 大象策略()
        
        # 禁用实际交易执行
        self.策略._实际执行交易 = lambda *args, **kwargs: {"订单ID": "test_order_001"}
        
        # 模拟账户和市场数据
        self.策略.资金管理.现金 = 1000000.0
        # 模拟持有股票
        self.策略.资金管理.持仓 = {"000001": {"总数量": 10000, "可交易数量": 10000, "冻结数量": 0, "成本": 10.0}}
    
    def test_完整交易流程(self):
        """测试从识别大象到下单的完整流程"""
        # 创建大象盘口数据
        大象盘口 = {
            "bid": [[9.90, 10000], [9.85, 50000], [9.80, 102041]],  # 第三档是100万元
            "ask": [[10.00, 5000], [10.05, 3000]]
        }
        
        # 模拟大象识别
        # 直接设置大象跟踪状态，跳过时间检查
        self.策略.大象识别.大象跟踪 = {
            "000001": {
                9.80: {
                    "确认次数": 3,
                    "首次发现时间": datetime.now() - timedelta(seconds=10)
                }
            }
        }
        
        # 模拟盘口数据更新
        self.策略.on_tick({"symbol": "000001", "datetime": datetime.now(), "last_price": 10.0, "bid": 大象盘口["bid"], "ask": 大象盘口["ask"]})
        
        # 检查是否触发交易
        self.assertIn("test_order_001", self.策略.交易执行.活跃订单)
        订单 = self.策略.交易执行.活跃订单["test_order_001"]
        self.assertEqual(订单["类型"], "卖出")
        self.assertEqual(订单["股票代码"], "000001")
        
        # 模拟订单成交
        成交数据 = {
            "订单ID": "test_order_001",
            "成交价格": 9.9,  # 以略高于大象价格的价格卖出
            "成交数量": 1000
        }
        self.策略.交易执行.更新订单状态(成交数据)
        
        # 检查是否创建买回订单
        买回订单ID = None
        for 订单ID, 订单信息 in self.策略.交易执行.活跃订单.items():
            if 订单信息["类型"] == "买入":
                买回订单ID = 订单ID
                break
        
        self.assertIsNotNone(买回订单ID)
        买回订单 = self.策略.交易执行.活跃订单[买回订单ID]
        self.assertEqual(买回订单["股票代码"], "000001")
        self.assertEqual(买回订单["数量"], 1000)
        
        # 模拟买回订单成交
        成交数据 = {
            "订单ID": 买回订单ID,
            "成交价格": 9.82,  # 以略高于大象价格的价格买回
            "成交数量": 1000
        }
        self.策略.交易执行.更新订单状态(成交数据)
        
        # 检查交易历史是否记录完整
        self.assertEqual(len(self.策略.交易执行.交易历史), 1)
        交易记录 = self.策略.交易执行.交易历史[0]
        self.assertEqual(交易记录["股票代码"], "000001")
        self.assertEqual(交易记录["卖出价格"], 9.9)
        self.assertEqual(交易记录["买回价格"], 9.82)
        self.assertEqual(交易记录["状态"], "已完成")
        self.assertEqual(交易记录["盈亏"], (9.9 - 9.82) * 1000)  # 应该盈利80元
```

## 数据结构与接口

### 主要数据结构

大象策略定义了一系列核心数据结构，支撑整个系统的运行：

#### 1. 持仓数据结构

持仓数据是资金管理模块的核心，记录所有股票持仓信息和T+1状态：

```python
# 持仓数据结构
self.持仓 = {
    "股票代码1": {
        "总数量": 1000,         # 该股票的总持仓数量
        "可交易数量": 800,      # 当天可卖出的数量
        "冻结数量": 200,        # 当天买入的数量（T+1规则下被冻结）
        "买入时间": {           # 记录每笔买入的时间，用于自动解冻
            "批次1": {"数量": 200, "时间": datetime对象1},
            "批次2": {"数量": 800, "时间": datetime对象2}
        },
        "成本": 10.5,           # 平均成本价
        "最新价": 10.8,         # 最新市场价格
        "市值": 10800.0,        # 当前市值
        "浮盈": 300.0,          # 浮动盈亏
        "日内成交": 5           # 该股票日内成交次数
    },
    # 其他股票...
}
```

#### 2. 大象跟踪结构

大象识别模块使用特定数据结构跟踪潜在的大象买单：

```python
# 大象跟踪结构
self.大象跟踪 = {
    "股票代码1": {
        价格1: {
            "确认次数": 2,              # 当前已确认次数
            "首次发现时间": datetime对象  # 首次发现该价位大象的时间
        },
        价格2: {
            "确认次数": 1,
            "首次发现时间": datetime对象
        }
    },
    # 其他股票...
}
```

#### 3. 交易历史结构

交易执行模块记录所有交易历史，用于分析和报告：

```python
# 交易历史记录
self.交易历史 = [
    {
        "股票代码": "股票代码1",
        "卖出价格": 10.5,
        "卖出数量": 1000,
        "卖出时间": datetime对象1,
        "卖出订单ID": "订单ID1",
        "预计买回价格": 10.4,
        "买回价格": 10.38,        # 实际买回价格，可能与预计不同
        "买回数量": 1000,
        "买回时间": datetime对象2,
        "买回订单ID": "订单ID2",
        "状态": "已完成",         # 可能的状态：已卖出待买回、已完成、买回失败
        "盈亏": 120.0            # (卖出价格 - 买回价格) * 数量
    },
    # 其他交易记录...
]
```

#### 4. 风控记录结构

风险控制模块维护风控触发记录，用于审计和分析：

```python
# 风控触发记录
self.风控触发记录 = [
    {
        "时间": datetime对象,
        "原因": "日内总亏损10000元超过阈值5000元",
        "累计亏损": 10000.0,
        "总资产": 500000.0,
        "操作": "自动触发"  # 或"管理员手动复位"
    },
    # 其他风控记录...
]
```

### 主要接口

大象策略定义了一系列关键接口，用于模块间通信和外部交互：

#### 1. 策略主接口

主策略类提供的关键接口：

```python
class 大象策略(CtaTemplate):
    """大象策略主类"""
    
    # 继承自VNPY的关键接口
    def on_init(self):
        """策略初始化"""
        # 初始化各个模块
        # 加载历史数据
        
    def on_start(self):
        """策略启动"""
        # 启动各个模块
        # 开始交易循环
        
    def on_stop(self):
        """策略停止"""
        # 停止交易
        # 保存状态
        
    def on_tick(self, tick):
        """行情数据更新回调"""
        # 处理最新行情数据
        # 触发大象识别
        
    def on_trade(self, trade):
        """成交回报回调"""
        # 处理成交信息
        # 更新订单状态
        
    # 自定义接口
    def 执行交易决策(self):
        """执行交易决策流程"""
        # 分析大象识别结果
        # 执行交易逻辑
        
    def 风控检查(self):
        """执行风控检查"""
        # 检查风控状态
        # 必要时中止交易
```

#### 2. 模块间通信接口

各模块之间的关键通信接口：

```python
# 大象识别 -> 交易执行
def 检测大象(self, 股票代码, 盘口数据):
    """检测是否存在大象买单支撑"""
    # 返回: (是否存在大象, 大象价格)

# 交易执行 -> 资金管理
def 检查可卖数量(self, 股票代码, 请求数量):
    """检查可用于交易的数量"""
    # 返回: 实际可交易数量

# 交易执行 -> 风险控制
def 交易前检查(self, 股票代码, 交易金额, 总资产):
    """检查交易是否符合风控要求"""
    # 返回: {"允许交易": True/False, "原因": "原因说明"}
```

#### 3. 网页管理API接口

网页管理模块对外提供的REST API接口：

```
GET /api/status
- 功能：获取策略当前状态
- 返回：JSON格式的策略状态数据

GET /api/params
- 功能：获取当前参数设置
- 返回：JSON格式的参数数据

POST /api/params
- 功能：更新参数设置
- 参数：JSON格式的新参数值
- 返回：更新结果

GET /api/trades
- 功能：获取交易记录
- 查询参数：date(日期), code(股票代码)
- 返回：符合条件的交易记录和统计信息

POST /api/control
- 功能：执行控制命令
- 参数：command(命令类型), token(访问令牌), [其他命令参数]
- 返回：命令执行结果

GET /api/logs
- 功能：获取日志记录
- 查询参数：level(日志级别), limit(条数限制)
- 返回：符合条件的日志记录
```

## 总结

大象策略是一个专为A股T+1交易规则设计的高频交易策略，通过识别大额买单支撑（"大象"）进行先卖后买的交易，实现日内高频操作。

### 技术特点

1. **模块化设计**：策略由多个功能明确的模块组成，包括大象识别、资金管理、交易执行、风险控制和网页管理，各模块独立且协同工作。

2. **T+1规则适应**：通过精确的持仓管理机制，实现了对A股T+1交易规则的完美适配，确保交易合规性。

3. **实时风险控制**：多层次的风控机制确保策略在复杂市场环境中的安全运行，避免过度损失。

4. **网页远程管理**：内置的网页管理界面提供了便捷的远程监控和控制能力，增强了策略的可用性。

5. **完善的测试体系**：内置测试模块确保各组件功能正常并符合预期，提高了策略的稳定性和可靠性。

### 核心优势

1. **无需隔夜持仓**：策略主要在日内执行高频交易，避免了隔夜风险。

2. **灵活的资金管理**：通过股票池和现金池的动态平衡，既保证了交易活力，又维持了安全保障。

3. **精确的风险限制**：多维度的风控指标和动态调整机制，确保风险可控。

4. **可视化监控**：实时的数据展示和控制界面，提供了直观的策略管理体验。

5. **自动化交易**：从识别机会到执行交易全流程自动化，减少人工干预。

大象策略通过其独特的设计和实现，为高频交易提供了一个专业、稳定且高效的解决方案，特别适合于中国A股T+1交易环境。